## リポジトリ構成と実装手順（Workers 単一ホスト方式）

このプロジェクトは、1 つの Cloudflare Workers 上で「React の静的配信」「Hono ベースの API」「Durable Objects（DO）」を同居させ、同一オリジンで低レイテンシかつシンプルに運用します。仕様は `docs/全員一致ゲーム.md` に準拠します。

### ディレクトリ構成（案）

```
/src
	/client               # React（Vite, tailwind, GSAP）
		/pages
		/components
		/lib/api.ts
		main.tsx
		index.html
	/server               # Hono + Durable Objects（API と WS）
		index.ts            # Hono エントリ
		/routes
			rooms.ts          # REST/WS エンドポイント
		/do
			RoomDurable.ts    # Durable Object 実装
	/shared               # クライアント/サーバー共通の型
		types.ts            # docs の型を厳密に反映

wrangler.toml           # DO バインディングと静的アセット配信設定
```

### 開発フロー

1. Vite でフロントを開発、Wrangler dev で API/DO を起動
2. 開発中は assets.dev_server で Vite(5173) へリバースプロキシ
3. 本番は `vite build` で `dist/client` を生成し、Workers の assets として配信

### スクリプト（例）

- dev: `wrangler dev`（assets.dev_server で Vite に委譲）
- dev:client: `vite`
- build:client: `vite build`
- deploy: `wrangler deploy`

### ルーティング方針

- 静的: `/` および `/assets/*` は assets から配信
- API: `/api/*` に集約（`docs/全員一致ゲーム.md` のエンドポイントに準拠）
- WS: `/ws/:id` で DO に接続し、現状態の即時送信と以後の更新配信

### 認可

- GM 操作は `gmToken` 必須（ルーム作成時に払い出し、LocalStorage に保持）
- DO 側で `gmId` と `gmToken` の整合を検証

### 永続化

- ルーム内の全状態（ユーザー、設定、進行状況）は DO のメモリ上で管理
- ルーム終了や解散で状態は破棄（ストレージへの put は行わない）

---

## Cloudflare 設定例（wrangler.toml）

```toml
name = "unanimous-game"
main = "src/server/index.ts"
compatibility_date = "2024-06-20"

[assets]
# React Router のビルド成果物を配信（react-router build 後の出力）
directory = "src/client/build/client"
binding = "ASSETS"

[[durable_objects.bindings]]
name = "ROOM_DURABLE"
class_name = "RoomDurable"

[observability]
logs = { enabled = true }
```

補足
- wrangler v4 では `assets.dev_server` は非推奨のため未使用。開発中は `npm run dev:client`（Vite）と `npm run dev`（Workers）を併用し、必要に応じて `npm run build:client` を実行してアセットを更新する。
- Workers 上の SSR は Node 組み込みモジュール（fs/path/stream）を含むため `@react-router/node` が解決できずエラーになります。本プロジェクトは SPA モード（`src/client/react-router.config.ts` の `ssr:false`）で配信し、未マッチは `index.html` にフォールバックする構成に変更しています。

---

## 共有型（`src/shared/types.ts`）

```ts
export type User = {
  id: string;
  name: string;
  icon: string;
  isGM: boolean;
};

export type RoomSettings = {
  topicMode: "gm" | "all";
  winCondition:
    | { type: "count"; value: number }
    | { type: "consecutive"; value: number }
    | { type: "none" };
};

export type Answer = {
  userId: string;
  value: string;
  submittedAt: number;
};

export type Round = {
  id: string;
  topic: string;
  setterId: string;
  answers: Answer[];
  result: "unopened" | "opened";
  unanimous: boolean | null;
};

export type Room = {
  id: string; // 4桁番号
  gmId: string;
  users: User[];
  settings: RoomSettings;
  status: "waiting" | "playing" | "finished";
  rounds: Round[];
};
```

---

## Durable Object スケルトン（`src/server/do/RoomDurable.ts`）

```ts
import type { Room } from "../../shared/types";

export interface Env {
  ROOM_DURABLE: DurableObjectNamespace;
  ASSETS: Fetcher;
}

export class RoomDurable {
  private state: DurableObjectState;
  private env: Env;

  // インメモリ状態（永続化しない）
  private room: Room | null = null;
  private sockets = new Set<WebSocket>();

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;
  }

  // DO エントリポイント
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    // 必要に応じて /join /start /answer /open などを実装
    if (
      url.pathname.endsWith("/ws") &&
      request.headers.get("Upgrade") === "websocket"
    ) {
      const pair = new WebSocketPair();
      const [client, server] = Object.values(pair) as [WebSocket, WebSocket];
      server.accept();
      this.sockets.add(server);
      server.addEventListener("close", () => this.sockets.delete(server));
      // 接続直後に現状態を送信
      if (this.room)
        server.send(JSON.stringify({ type: "state", room: this.room }));
      return new Response(null, { status: 101, webSocket: client });
    }

    return new Response("OK");
  }

  private broadcast(payload: unknown) {
    const data = JSON.stringify(payload);
    for (const ws of this.sockets) {
      try {
        ws.send(data);
      } catch {}
    }
  }
}
```

---

## Hono エントリ（`src/server/index.ts`）

```ts
import { Hono } from "hono";
import type { Env } from "./do/RoomDurable";

const app = new Hono<{ Bindings: Env }>();

// API ルートのマウント（例）
// app.route('/api', apiRoutes);

// 静的配信: まず ASSETS にフォールバック
app.all("*", async (c) => {
  // API は先に return する（例: if (c.req.path.startsWith('/api/')) return api.fetch(c.req.raw, c.env)）
  // ここでは静的へ委譲
  const res = await c.env.ASSETS.fetch(c.req.raw);
  return res;
});

export default app;
```

---

## 次にやること（メモ）

- Vite + React + TypeScript の初期化、tailwind/GSAP 導入
- wrangler.toml を上記テンプレで作成
- `/src/shared/types.ts` を作成し型を単一出典化
- DO クラスと `/api` ルートの雛形を実装し、`wrangler dev` で起動確認

---

## GitHub 連携と Cloudflare Workers への GUI デプロイ（Durable Objects 含む）

### 1) ローカル Git の整理（ルートに一本化）

create-react-router により `src/client/.git` が生成されている場合は、ルートで 1 リポジトリに統一する。

```bash
# ルートに移動
cd /Users/k24083kk/development/unanimous-game

# クライアント配下のネストされた Git を削除（ファイルは削除されません）
rm -rf src/client/.git

# ルートを Git 初期化して初回コミット
git init
git add .
git commit -m "chore: init repo (workers + react-router + DO skeleton)"
```

### 2) GitHub に新規リポジトリを作成して push

GitHub で空のリポジトリ（例: `yourname/unanimous-game`）を作成し、以下を実行:

```bash
git branch -M main
git remote add origin git@github.com:yourname/unanimous-game.git
git push -u origin main
```

### 3) Cloudflare ダッシュボードで Workers を Git 連携

1. Cloudflare ダッシュボード → Workers & Pages → Create → "Workers" を選択
2. "Connect to Git" を選び、GitHub App をインストール（未インストール時）
3. 対象リポジトリを選択（ブランチ: main）
4. Build 設定（GUI）
  - Install command: `npm ci`
  - Build command: `npm run build:client`  # 内部で src/client の依存インストールとビルドを実行
  - Wrangler: リポジトリ直下の `wrangler.toml` を自動検出
5. 右下の "Save and Deploy" で初回デプロイ

ポイント
- Durable Objects は `wrangler.toml` の `[[durable_objects.bindings]]` と `[[migrations]]` により自動でクラス作成・マイグレーションされる（初回デプロイ時）。このリポジトリでは `RoomDurable` の v1 マイグレーションが設定済み。
- `assets.directory = src/client/build/client` のため、Git デプロイ時も Build command でクライアントを先にビルドしてから Wrangler がデプロイする流れになる。

### 4) 動作確認

- デプロイ後、Workers の URL（`*.workers.dev`）へアクセスしてトップが表示されることを確認
- DO の作成確認: Dashboard → Workers & Pages → Durable Objects → Classes に `RoomDurable` が存在する
- ヘルスチェック: `GET /api/health` が `{ ok: true }` を返す
- WebSocket: `GET /ws/:id` へブラウザ/スクリプトから接続（例: `ws://<your>.workers.dev/ws/1234`）。初回は DO から現状態（空）が push される。

### 5) 以降のデプロイ

- main ブランチに push → 自動で Cloudflare がビルド＆デプロイ
- DO のクラス追加/名称変更などスキーマ更新時は `[[migrations]]` に新しい `tag` を追記してコミット→push（GUI で自動適用）

---

## ローカル開発の流れ（最新版）

```bash
# 1) フロントの開発（Vite）
npm run dev:client

# 2) Workers の起動（Hono + DO）: 別ターミナルで
npm run dev

# 3) SSR/静的配信で確認したいとき
npm run build:client && npm run dev
```

補足
- wrangler の "assets" はビルド済みの静的を配信。ホットリロード用途には Vite の dev を使い、Worker 側は API/WS の確認に集中するのがシンプル。
