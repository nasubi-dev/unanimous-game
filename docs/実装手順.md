## リポジトリ構成と実装手順（Workers 単一ホスト方式）

このプロジェクトは、1 つの Cloudflare Workers 上で「React の静的配信」「Hono ベースの API」「Durable Objects（DO）」を同居させ、同一オリジンで低レイテンシかつシンプルに運用します。仕様は `docs/全員一致ゲーム.md` に準拠します。

### ディレクトリ構成（案）

```
/src
	/client               # React（Vite, tailwind, GSAP）
		/pages
		/components
		/lib/api.ts
		main.tsx
		index.html
	/server               # Hono + Durable Objects（API と WS）
		index.ts            # Hono エントリ
		/routes
			rooms.ts          # REST/WS エンドポイント
		/do
			RoomDurable.ts    # Durable Object 実装
	/shared               # クライアント/サーバー共通の型
		types.ts            # docs の型を厳密に反映

wrangler.toml           # DO バインディングと静的アセット配信設定
```

### 開発フロー

1. Vite でフロントを開発、Wrangler dev で API/DO を起動
2. 開発中は assets.dev_server で Vite(5173) へリバースプロキシ
3. 本番は `vite build` で `dist/client` を生成し、Workers の assets として配信

### スクリプト（例）

- dev: `wrangler dev`（assets.dev_server で Vite に委譲）
- dev:client: `vite`
- build:client: `vite build`
- deploy: `wrangler deploy`

### ルーティング方針

- 静的: `/` および `/assets/*` は assets から配信
- API: `/api/*` に集約（`docs/全員一致ゲーム.md` のエンドポイントに準拠）
- WS: `/ws/:id` で DO に接続し、現状態の即時送信と以後の更新配信

### 認可

- GM 操作は `gmToken` 必須（ルーム作成時に払い出し、LocalStorage に保持）
- DO 側で `gmId` と `gmToken` の整合を検証

### 永続化

- ルーム内の全状態（ユーザー、設定、進行状況）は DO のメモリ上で管理
- ルーム終了や解散で状態は破棄（ストレージへの put は行わない）

---

## Cloudflare 設定例（wrangler.toml）

```toml
name = "unanimous-game"
main = "src/server/index.ts"
compatibility_date = "2024-06-20"

[assets]
# React Router のビルド成果物を配信（react-router build 後の出力）
directory = "src/client/build/client"
binding = "ASSETS"

[[durable_objects.bindings]]
name = "ROOM_DURABLE"
class_name = "RoomDurable"

[observability]
logs = { enabled = true }
```

補足
- wrangler v4 では `assets.dev_server` は非推奨のため未使用。開発中は `npm run dev:client`（Vite）と `npm run dev`（Workers）を併用し、必要に応じて `npm run build:client` を実行してアセットを更新する。
- Workers 上の SSR は Node 組み込みモジュール（fs/path/stream）を含むため `@react-router/node` が解決できずエラーになります。本プロジェクトは SPA モード（`src/client/react-router.config.ts` の `ssr:false`）で配信し、未マッチは `index.html` にフォールバックする構成に変更しています。

---

## 共有型（`src/shared/types.ts`）

```ts
export type User = {
  id: string;
  name: string;
  icon: string;
  isGM: boolean;
};

export type RoomSettings = {
  topicMode: "gm" | "all";
  winCondition:
    | { type: "count"; value: number }
    | { type: "consecutive"; value: number }
    | { type: "none" };
};

export type Answer = {
  userId: string;
  value: string;
  submittedAt: number;
};

export type Round = {
  id: string;
  topic: string;
  setterId: string;
  answers: Answer[];
  result: "unopened" | "opened";
  unanimous: boolean | null;
};

export type Room = {
  id: string; // 4桁番号
  gmId: string;
  users: User[];
  settings: RoomSettings;
  status: "waiting" | "playing" | "finished";
  rounds: Round[];
};
```

---

## Durable Object スケルトン（`src/server/do/RoomDurable.ts`）

```ts
import type { Room } from "../../shared/types";

export interface Env {
  ROOM_DURABLE: DurableObjectNamespace;
  ASSETS: Fetcher;
}

export class RoomDurable {
  private state: DurableObjectState;
  private env: Env;

  // インメモリ状態（永続化しない）
  private room: Room | null = null;
  private sockets = new Set<WebSocket>();

  constructor(state: DurableObjectState, env: Env) {
    this.state = state;
    this.env = env;
  }

  // DO エントリポイント
  async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url);
    // 必要に応じて /join /start /answer /open などを実装
    if (
      url.pathname.endsWith("/ws") &&
      request.headers.get("Upgrade") === "websocket"
    ) {
      const pair = new WebSocketPair();
      const [client, server] = Object.values(pair) as [WebSocket, WebSocket];
      server.accept();
      this.sockets.add(server);
      server.addEventListener("close", () => this.sockets.delete(server));
      // 接続直後に現状態を送信
      if (this.room)
        server.send(JSON.stringify({ type: "state", room: this.room }));
      return new Response(null, { status: 101, webSocket: client });
    }

    return new Response("OK");
  }

  private broadcast(payload: unknown) {
    const data = JSON.stringify(payload);
    for (const ws of this.sockets) {
      try {
        ws.send(data);
      } catch {}
    }
  }
}
```

---

## Hono エントリ（`src/server/index.ts`）

```ts
import { Hono } from "hono";
import type { Env } from "./do/RoomDurable";

const app = new Hono<{ Bindings: Env }>();

// API ルートのマウント（例）
// app.route('/api', apiRoutes);

// 静的配信: まず ASSETS にフォールバック
app.all("*", async (c) => {
  // API は先に return する（例: if (c.req.path.startsWith('/api/')) return api.fetch(c.req.raw, c.env)）
  // ここでは静的へ委譲
  const res = await c.env.ASSETS.fetch(c.req.raw);
  return res;
});

export default app;
```

---

## 次にやること（メモ）

以下の最小プレイフローを段階的に実装する。

1) 共有型の拡張（WS イベント）
- Client→Server: `join`, `leave`, `answer`, `startRound`, `openRound`, `ping`
- Server→Client: `state`, `userJoined`, `userLeft`, `roundStarted`, `answerUpdated`, `roundOpened`, `pong`, `error`

2) API ルートの追加（Hono, `src/server/index.ts`）
- POST `/api/rooms` … 新規部屋作成 → `{ roomId, gmId, gmToken }`
- POST `/api/rooms/:id/join` … `{ name }` で参加 → `{ userId }`
- GET `/api/rooms/:id/state` … 現在状態を返す
- 既存の GET `/ws/:id` は DO へフォワード済み

3) Durable Object の実装（`src/server/do/RoomDurable.ts`）
- HTTP:
  - POST `/create` … roomId/gmId/gmToken を発行して初期化
  - POST `/join` … name を受けて userId を払い出し、`room.users` に追加、`userJoined` を broadcast
  - GET `/state` … 現在の `room` を返す
- WS:
  - 接続直後に `state` を送る
  - 受信イベントに応じて状態を更新し、全接続へ broadcast
  - GM 操作（`startRound`, `openRound`）は `gmToken` を検証

4) クライアントの配線（`src/client`）
- `lib/api.ts` … 上記 API 呼び出しラッパ（gmToken は LocalStorage 保持）
- 画面:
  - トップ: ルーム作成/参加フォーム
  - `/room/:id`: WS 接続して `state` を描画（参加者一覧などの簡易 UI）
  - 切断時の再接続（指数バックオフ）

5) 動作確認
- `POST /api/rooms` → 戻り `{roomId, gmToken}` 取得
- 別ブラウザで `POST /api/rooms/:id/join` → `userJoined` が WS で届く
- `GET /api/rooms/:id/state` でフォールバック確認

---

## ローカル開発の流れ（最新版）

```bash
# 1) フロントの開発（Vite）
npm run dev:client

# 2) Workers の起動（Hono + DO）: 別ターミナルで
npm run dev

# 3) SSR/静的配信で確認したいとき
npm run build:client && npm run dev
```

---

## UI 微調整（Tailwind）とUXルール

- Tailwind を全体スタイルに採用（`app.css` で `@import "tailwindcss"` 済み）
- フォームのバリデーションと状態に応じたボタン制御
  - トップ画面: 名前未入力時は「Create Room/Join Room」ボタンを `disabled` にする
  - `disabled` 時は `bg-gray-400 cursor-not-allowed`、有効時は `hover` 色を付与
- 参加/作成時のエラーハンドリング
  - API 失敗時にトーストメッセージを表示（400 のときは詳細を表示）
  - API ラッパに `ApiError` を追加し、`status` と `body` を保持
- ルーム画面での Users 表示
  - `isGM: true` のユーザーに GM バッジを表示（琥珀色の小バッジ）

実装箇所
- `src/client/app/lib/api.ts`: `ApiError` を追加し、各 API エラー時に本文を取り出し投げ直し
- `src/client/app/welcome/welcome.tsx`: disabled ボタンとトースト実装
- `src/client/app/routes/room.tsx`: Users リストに GM バッジ、エラートースト

---

## ゲーム開始前のルール設定の実装タスク一覧

ゲームの「待機中（waiting）」フェーズで GM がルールを設定できるようにするための作業一覧です。

サーバー/DO 側
1. 型の拡張（`src/shared/types.ts`）
   - `RoomSettings` の初期値を明示（例: `topicMode: "gm"`, `winCondition: { type: "none" }`）
   - 変更イベント型を追加
     - WS: `settingsUpdated`（payload: `settings: RoomSettings`）
   - API リクエスト型
     - `UpdateSettingsRequest { settings: Partial<RoomSettings>, gmToken: string }`
2. DO のエンドポイント追加（`RoomDurable.ts`）
   - POST `/settings`（GM 専用）
     - `gmToken` を検証し、`room.settings` を部分更新
     - 全接続へ `settingsUpdated` を broadcast
   - GET `/state` で `settings` を常に返却（既存）
3. API のルート追加（`src/server/index.ts`）
   - PATCH `/api/rooms/:id/settings` → DO の `/settings` にフォワード
   - 認可エラーは 403、バリデーションエラーは 400 を返す

クライアント側
4. API ラッパ（`src/client/app/lib/api.ts`）
   - `updateSettings(id, body: UpdateSettingsRequest)` の追加
5. UI（`/room/:id` 画面）
   - 待機中のみ設定UIを表示
     - トピック出題者: ラジオ（GM/全員）
     - 勝利条件: セレクト（カウント/連続/なし）＋値入力（数値）
   - 保存ボタン押下で `updateSettings` を呼び、成功後は反映を待たずに楽観更新、WS の `settingsUpdated` で最終反映
   - GM 以外は読み取り専用表示
6. LocalStorage
   - ルーム作成時に受け取る `gmToken` を `localStorage.gmToken:<roomId>` として保存/読み出し

バリデーション/エッジケース
- `waiting` 以外では設定更新を拒否（DO 側）
- `winCondition.value` は 1 以上の整数、または `none` のときは未設定
- 未参加ユーザー/未接続クライアントからの更新は 403
- 大量の設定変更スパムに対するデバウンス（UI 側 300ms）

手順サマリ
1) 型を追加 → 2) DO に `/settings` 実装 → 3) Hono の `/api/rooms/:id/settings` 追加 → 4) クライアント API & UI 実装 → 5) 動作確認

---

## ゲーム開始以降の実装タスク一覧

ルーム設定が完了した後の「ゲーム開始→ラウンド実行→結果判定」フローの実装に必要な作業です。

### 1. ゲーム開始機能の実装

#### サーバー/DO 側
1. 型の拡張（`src/shared/types.ts`）
   - ゲーム開始イベント型を追加
     - WS: `gameStarted`（payload: `{ room: Room }`）
   - API リクエスト型
     - `StartGameRequest { gmToken: string }`

2. DO のエンドポイント追加（`RoomDurable.ts`）
   - POST `/start`（GM 専用）
     - `gmToken` を検証
     - `room.status` を `'waiting'` から `'playing'` に変更
     - 全接続へ `gameStarted` を broadcast

3. API のルート追加（`src/server/index.ts`）
   - POST `/api/rooms/:id/start` → DO の `/start` にフォワード

#### クライアント側
4. API ラッパ（`src/client/app/lib/api.ts`）
   - `startGame(id: string, gmToken: string)` の追加

5. UI（`/room/:id` 画面）
   - 待機中に「ゲーム開始」ボタンを表示（GM のみ）
   - ボタン押下で `startGame` を呼び出し
   - WS の `gameStarted` イベントで状態更新

### 2. ラウンド実行機能の実装

#### サーバー/DO 側
1. 型の拡張（`src/shared/types.ts`）
   - ラウンド関連イベント型を追加
     - WS: `roundCreated`（payload: `{ round: Round }`）
     - WS: `topicSet`（payload: `{ roundId: string, topic: string }`）
     - WS: `answerSubmitted`（payload: `{ roundId: string, userId: string, hasAnswered: boolean }`）
     - WS: `roundOpened`（payload: `{ roundId: string, answers: Answer[] }`）
   - API リクエスト型
     - `CreateRoundRequest { gmToken: string }`
     - `SetTopicRequest { roundId: string, topic: string, setterId: string }`
     - `SubmitAnswerRequest { roundId: string, userId: string, value: string }`
     - `OpenRoundRequest { roundId: string, gmToken: string }`

2. DO のエンドポイント追加（`RoomDurable.ts`）
   - POST `/round` → 新しいラウンドを作成
     - `playing` 状態でのみ実行可能
     - ラウンド ID を生成し `room.rounds` に追加
     - 出題者を設定（GM固定 or 次の人）
   - POST `/round/:roundId/topic` → お題設定
     - 設定権限のあるユーザーのみ実行可能
     - お題を設定し `topicSet` を broadcast
   - POST `/round/:roundId/answer` → 回答送信
     - 回答を追加し `answerSubmitted` を broadcast
   - POST `/round/:roundId/open` → 回答オープン（GM 専用）
     - `result` を `'opened'` に変更
     - 全回答を公開し `roundOpened` を broadcast

3. API のルート追加（`src/server/index.ts`）
   - POST `/api/rooms/:id/round` → DO の `/round` にフォワード
   - POST `/api/rooms/:id/round/:roundId/topic` → DO の `/round/:roundId/topic` にフォワード
   - POST `/api/rooms/:id/round/:roundId/answer` → DO の `/round/:roundId/answer` にフォワード
   - POST `/api/rooms/:id/round/:roundId/open` → DO の `/round/:roundId/open` にフォワード

#### クライアント側
4. API ラッパ（`src/client/app/lib/api.ts`）
   - `createRound(roomId: string, gmToken: string)`
   - `setTopic(roomId: string, roundId: string, topic: string, setterId: string)`
   - `submitAnswer(roomId: string, roundId: string, userId: string, value: string)`
   - `openRound(roomId: string, roundId: string, gmToken: string)`

5. UI（`/room/:id` 画面）
   - ゲーム中の画面レイアウト
     - 現在のラウンド表示
     - お題設定フォーム（権限のあるユーザーのみ）
     - 回答入力フォーム
     - 回答状況表示（誰が回答済みか）
     - 回答オープンボタン（GM のみ）
     - 回答結果表示

### 3. 結果判定機能の実装

#### サーバー/DO 側
1. 型の拡張（`src/shared/types.ts`）
   - 結果判定イベント型を追加
     - WS: `resultJudged`（payload: `{ roundId: string, unanimous: boolean }`）
     - WS: `gameFinished`（payload: `{ room: Room, winCondition: boolean }`）
   - API リクエスト型
     - `JudgeResultRequest { roundId: string, unanimous: boolean, gmToken: string }`

2. DO のエンドポイント追加（`RoomDurable.ts`）
   - POST `/round/:roundId/result` → 結果判定
     - `unanimous` を設定
     - 勝利条件をチェック（達成時は `room.status` を `'finished'` に）
     - `resultJudged` / `gameFinished` を broadcast
     - 次のラウンド準備（勝利条件未達成時）

3. ロジック実装
   - 勝利条件判定ロジック
     - `count`: 一致回数をカウント
     - `consecutive`: 連続一致回数をカウント
     - `none`: 判定なし
   - 次の出題者選択ロジック（`topicMode: 'all'` の場合）

#### クライアント側
4. API ラッパ（`src/client/app/lib/api.ts`）
   - `judgeResult(roomId: string, roundId: string, unanimous: boolean, gmToken: string)`

5. UI（`/room/:id` 画面）
   - 結果判定画面
     - 全回答の表示
     - 「全員一致」「一致しなかった」ボタン
     - 一致結果の表示
     - 進行状況表示（勝利条件に対する現在の状況）
   - ゲーム終了画面
     - 勝利演出（GSAP アニメーション）
     - 最終結果表示
     - 新しいゲーム開始ボタン

### 4. ゲーム進行管理とUX改善

#### 状態管理の強化
1. フロー制御
   - 各フェーズでの適切なボタンの有効/無効化
   - エラーハンドリング（不正な状態遷移の防止）
   - 再接続時の状態復旧

2. リアルタイム更新
   - 回答状況のリアルタイム表示
   - タイマー機能（オプション）
   - 進行状況の同期

#### アニメーション・演出
3. GSAP を使った演出
   - 回答オープン時のアニメーション
   - 結果発表の演出
   - ゲームクリア時の祝福演出

#### エラー処理・バリデーション
4. バリデーション強化
   - 空の回答の防止
   - 重複回答の防止
   - タイムアウト処理

### 実装優先度

**Phase 1: 最小プレイ可能版**
1. ゲーム開始機能
2. ラウンド作成・お題設定
3. 回答送信・オープン
4. 基本的な結果判定

**Phase 2: ゲーム体験の向上**
1. 勝利条件判定
2. 次のラウンド自動生成
3. 進行状況表示

**Phase 3: 演出・UX強化**
1. アニメーション追加
2. エラー処理強化
3. 再接続処理
4. レスポンシブ対応

### 開発・テストフロー
1. DO の各エンドポイントを単体でテスト
2. フロントエンドの状態管理ロジックを実装
3. WebSocket イベントの送受信テスト
4. エンドツーエンドの動作確認
5. 複数ブラウザでの同時プレイテスト


## iconはここ
https://iconbu.com/info